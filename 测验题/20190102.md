## 基础测验

### 例1
```js
    alert(a); // function a () { ... }
    a(); // 10
    var a = 3;
    function a() {
        alert(10);
    }
    alert(a); // 3
    a = 6;
    a(); // a is not a function
```

**解析**

声明存在提升，且函数声明优先于变量声明。

**巩固**

```js
foo();
bar(); // 函数表达式foo1不会提升 此bar为undefined bar is not a function
function foo() {
    console.log( a ); // undefined，a声明时在函数作用域内被提升
    var a = 2;
}
var bar = function foo1() {
    console.log(bar)
}

```
1. (每个)作用域中，总是先声明，再赋值，所有的声明会被提升到各自作用域的顶端。
2. 函数声明会被提升且优先于变量声明，但函数表达式不会被提升。


### 例2

```js
this.a = 20;
var test = {
    a: 40,
    init:()=> { //箭头函数 作用域绑定当前词法作用域window
        console.log(this.a); //20
        function go() {
            console.log(this.a); //50  go被new 属性查找从实例的属性到原型逐级上升查找，找到go.prototype.a = 50,
        }
        go.prototype.a = 50;
        return go;
    }
};
new(test.init())();
```
---

```js
this.a = 20;
var test = {
    a: 40,
    init:()=> {
        console.log(this.a);
        function go() {
            this.a = 60;
            console.log(this.a);
        }
        go.prototype.a = 50;
        return go;
    }
};
var p = test.init(); // 20 箭头函数绑定window
p(); // 60 window.p() this.a = 60 相当于 window.a = 60
new(test.init())(); // 1.60 箭头函数绑定window 此时window.a = 60 。 2. 60 new go() 直接找到实例属性 a = 60
```

**解析**

1. 可以肤浅地认为，this的指向为调用者,需要注意箭头函数的作用域绑定。
2. 实例属性的查找：当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

---

### 例3 点击li输出li内的值
```html
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
</ul>
<script type="text/javascript">
    var list_li = document.getElementsByTagName("li");
    for (var i = 0; i < list_li.length; i++) {
        list_li[i].onclick = function() {
            console.log(i); // for是同步执行的，事件绑定的回调在异步队列里。所以i在for执行完后就变成了6，点击li永远打印6
        }
    }
</script>

<script type="text/javascript">
    //解法1 this
    var list_li = document.getElementsByTagName("li");
    for (var i = 0; i < list_li.length; i++) {
        list_li[i].onclick = function() {
            console.log(this.innerHTML);
        }
    }
</script>

<script type="text/javascript">
    //解法2 let 
    var list_li = document.getElementsByTagName("li");
    for (let i = 0; i < list_li.length; i++) {
        list_li[i].onclick = function() {
            console.log('index', i);
        }
    }
</script>

<script type="text/javascript">
    //解法3 闭包
    var list_li = document.getElementsByTagName("li");
    for (let i = 0; i < list_li.length; i++) {
        (function(index) {
            list_li[i].onclick = function() {
                console.log('index', index);
            }
        })(i);
       
    }    
</script>

```

**解析**
本题重在考察this的运用

---

### 例4 
```js
function test(m) {
    m = { v: 5 }; //m被赋予了一个新的对象， 与外部传入的对象引用切断了联系
}
var m = { k: 30 };
test(m);
alert(m.v); //undefined  m = {k: 30} 
``` 
**解析**
虽然外部的m通过引用传递到了test方法内，但是由于m被重新赋值，因此引用被切断了。所以， 外部的m依然是 {k: 30};

---

### 例5  190102 直播22`

```js
function yideng() {
    console.log(1);
}
(function () {
    // 此处提升相当于 var yideng;
    if (false) {
        function yideng() {
            console.log(2);
        }
    }
    yideng(); //yideng is not a function
})();
```
**解析**
不同浏览器情况不同。早期浏览器，遵循函数提升原理，此处应该打印2。但是后期发现这是不合理的，因为条件判定无效了，所以浏览器进行了修正。于是，在现代浏览器中，会先把此处的具名**函数声明转换为变量**(变量名就是函数名)**声明**，然后再**当函数表达式被执行时，再给变量赋值**。参见例1中巩固第二点，函数声明会被提升且优先于变量声明，但**函数表达式不会被提升**。

**巩固**
```js
function yideng() {
    console.log(1);
}
(function () {
    // 此处提升相当于 var yideng;
    if (true) {
        function yideng() {
            console.log(2);
        }
    } else {
        function yideng() {
            console.log(3);
        }
    }
    yideng(); //2
})();
```

1. 此时输出2证明了解析是正确的。
2. 但是早期浏览器下，依然是函数提升，因此就会输出3。

---

### 例6 一句话算出0-100之间学生的学生等级，如90-100输出为1等生、80-90为2等生。不允许使用if switch等

```js
    var score = 81;
    var res = 10 - Math.floor(score / 10) // 2
```

**解析**
灵活使用数学方法，转变编程思维

---

### 例7 一句话遍历变量a。(禁止用for 已知var a = “abc”)


```js
    var a = "abc"
    Array.from(a);
    Array.prototype.slice.call(a);
    [...a];
    [...new Set(a)];
```


**解析**
借用方法

---

### 例8 JavaScript面向对象编程的混合式继承
见[继承](../javascript/继承.md)

---

### 例9 ES6/7 如何优化多步异步嵌套代码

```js
function asyncfn() {
    return new Promise((resolve, reject) => {
        console.log(111)
        setTimeout(function() {
            resolve(Math.random())
        }, 1000);
    })
}

asyncfn().then((res) => {
    console.log(res)
})

async function test() {
    const pro1 = asyncfn();
    const pro2 = asyncfn();
    const res1 = await pro1;
    const res2 = await pro2;
    console.log(res1)
    console.log(res2)
}
test();

```

### 例10

```js
var length = 10;

function fn() {
    console.log(this.length);
}

var yideng = {
    length: 5,
    method: function (fn) {
        fn(); // 10  没有调用者 调用者就是window 
        arguments[0](); // 2 arguments是独立的(类数组)对象，所以此时this指向arguments 长度为参数个数2
    }
};

yideng.method(fn, 1);

```