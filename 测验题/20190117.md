## 基础测验

### 例1
```js
    alert(a); //undefined
    yideng(); //yideng is not a function
    var flag = true;
    if(!flag){
        var a = 1;
    }

    if (flag) {
        function yideng() {
            console.log("yideng1");
        }
    } else {
        function yideng() {
            console.log("yideng2");
        }
    }
```

**解析**

函数提升和变量提升

---

### 例2

[传送门](./20190102.md/#例2)

---

### 例3： a会被GC回收吗？
```js
    function test(){
        var a = "yideng";
        return function(){
            eval("");
        }
    }
    test()()
```

**解析**

不会。eval欺骗词法作用域,因为并不知道a是否会被引用，所以不能回收。

**拓展**

欺骗词法作用域的方式还有with 和 new Function()
eval 和 try catch 不会被GC优化

1. LexicalEnvironment 全局词法作用域 eval
2. Function 创建所有函数的Scope -> LexicalEnvironment
3. with 浏览器一旦遇到 放弃回收所有变量
4. try会回收a 但是catch作用域被延长到全局词法作用域：catch->exception->LexicalEnvironment

**调试方法**

使用chrome开发者工具 Memory-Heap snapshot
在内存快照中可以看到Distance一栏，数值代表距离GC根节点距离
ctrl+f 可按照变量名进行搜索

---

### 例4

```js
    Object.prototype.a = 'a';
    Function.prototype.a = 'a1';
    function Person(){};
    var yideng = new Person();
    console.log('p.a:', yideng.a); // a 沿着原型链向上查找
    console.log(1..a); // 1. Number, 1.. Number.a
    console.log(1.a); //关键字.在这里是混淆的, exception
```

**解析**

1. yideng.\_\_proto__ == Person.prototype
2. Person.prototype.\_\_proto__ == Object.prototype

3. Person.\_\_proto__ == Function.prototype
4. Function.prototype.\_\_proto__ == Object.prototype

5. Object.\_\_proto__ == Function.prototype //构造函数Object
6. Number.\_\_proto__ == Function.prototype //构造函数Number
7. Function.\_\_proto__ == Function.prototype //与上述统一 构造函数原型都指向Function.prototype

---

### 例5 JavaScript面向对象编程的混合式继承

见[继承](../javascript/继承.md)

---

### 例6 元编程  对js编程

**1. Proxy**
```js
let person = {
    age: 29
}
const validator ={
    //target: 代理的对象 ,key: 键,value: 值
    set(target,key,value){
        if(typeof value !== "number"){
            throw new TypeError("age is not Number");
        }
    }
};
const proxy = new Proxy(person,validator);
proxy.age = "18";
```
使用Proxy代理处理对象


**2. Symbol** 
```js
const arr = [4, 4, 5, 6, 7, 8];
arr[Symbol.iterator] = function* () {
    let index = 1
    console.table(this);
    do {
        yield this[index];
    } while ((index += 2) < this.length)
}

for (const v of arr) {
    console.log(v);
}
```
http://es6.ruanyifeng.com/?search=symbol&x=0&y=0#docs/symbol



**3. Reflect**  reflect-metadata 
```js
Reflect.apply(this,1);
Reflect.defineMetadata(metadataKey, metadataValue, C.prototype, "method");

```
使用
https://github.com/rbuckton/reflect-metadata
---


### 例7

```js
const timeout = ms =>
    new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
const ajax1 = () =>
    timeout(2000).then(() => {
        console.log("1");
        return 1;
    });
const ajax2 = () =>
    timeout(1000).then(() => {
        console.log("2");
        return 2;
    });
const ajax3 = () =>
    timeout(2000).then(() => {
        console.log("3");
        return 3;
    });

const mergePromise = (ajaxArray) =>{
 //1,2,3 done [1,2,3]
 //【代码书写处】
    var result = [];
    const reducer =  (previousPromise, nextPromise) => previousPromise.then(() => {
        return nextPromise().then(res => result.push(res))
    });
 
   return ajaxArray.reduce(reducer, Promise.resolve()).then((res) => {
        console.log(res)
        return result
   });

} 

mergePromise([ajax1, ajax2, ajax3]).then(data => {
    console.log("done");
    console.log(data); // data 为 [1, 2, 3]
}); 
// 执行结果为： 1 2 3 done [1,2,3] 

```
**解析**

参考 ： https://segmentfault.com/a/1190000016832285?utm_source=tag-newest

### 例8

```html 
    <button id="test"></button>
```

```js
    $('#test').click(function(argument) {
        console.log(1);
    });
    setTimeout(function() {
        console.log(2);
    }, 0);
    while (true) {
        console.log(Math.random());
    }

```
**解析**

1. 点击按钮无反应 因为被while死循环堵截了同步栈，永远不能到异步队列
2. 如何解决？ 考虑模拟多线程。 
    1. 库： Concurrent.Thread.js
    2. WebWork：将繁杂业务独立出去，在后台运行，并通过相关api传递消息和返回。

参考： https://www.cnblogs.com/woodk/articles/5199536.html


### 例9 ES5 实现 ES6 Promise

```js
   //PromiseA+ 规范

```
**解析**

参考: 
https://www.jianshu.com/p/fe42b01ef076
https://blog.csdn.net/chenyidong521/article/details/80245140




### 例9 ES5 实现 ES6 Promise

```js
var s = [];
var arr = s;
for (var i = 0; i < 3; i++) {
    var pusher = {
        value: "item" + i
    }, tmp;
    if (i !== 2) {
        tmp = [];
        pusher.children = tmp; // children指向tmp []
    }
    arr.push(pusher);
    arr = tmp; // arr与上一次的children 都指向tmp []
}

console.log(s[0]);

```
**解析**

模拟指针移动

---

### 例10

```js

var Container = function(x) {
    this.__value = x;
}
Container.of = x => new Container(x);
Container.prototype.map = function(f){
    return Container.of(f(this.__value))  // of 函子 生成新的实例  函子是独立的  
}
Container.of(3)
.map(x => x + 1)
.map(x => 'Result is ' + x);

```

**解析**




