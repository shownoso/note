[传送门](#总结图)
## 一、实例
```js
function Car(color) {
    this.color = color;
}
var bmw = new Car('black');
console.log(bmw.color); // black
```
### 实例化发生了什么？
```js
//创建一个基本对象
var o = new Object(); 

//创建内置属性__proto__并指向构造函数的prototype;
o.__proto__ = Car.prototype;

//调用构造函数来构造自身，此时this指向自身，从而获得成员变量color
Car.call(o, 'black');

//返回该对象
return o;
```

**如果构造函数有返回值呢？**
```js
function Car(color) {
    this.color = color;
    //return any;
}
```
1. 没有返回值 ：默认情况，返回该实例
2. 简单数据类型 ：返回该实例
3. 对象类型 ：返回这个对象类型，而不是实例

## 原型 prototype
1. prototype是函数才有的属性，且每个函数都有一个prototype属性
2. prototype是函数的**实例的原型**

##  \_\_proto\_\_
1. 除null以外的js对象都具有的一个属性
2. 对象的__proto__属性指向它的原型，即其**构造函数的prototype**


```js
bmw.__proto__ === Car.prototype //true
```

## constructor
每个原型都有一个constructor属性指向关联的构造函数。
```js
Car.prototype.constructor === Car //true
```

## 原型链 
- bmw.\_\_proto__ => Car.prototype  
- Car.prototype.\_\_proto__ => Object.prototype
- Object.prototype.\_\_proto__ => null

## 实例属性的查找
当读取实例对象的属性时，如果找不到，就会查找与该对象关联的原型中的属性(沿着原型链查找)

## 结论
实例对象的__proto__属性指向它的构造函数的prototype(原型)
```js
// o: 实例对象
// O: o的构造函数
o.__proto__ === O.prototype
```


## 总结图
如图所示，有一点很特别 Function.\_\_proto\_\_ === Function.prototype。首先这是规范定制的，其次Function是函数，当然应该由函数原型来构造。

![image](http://www.mollypages.org/tutorials/jsobj.jpg)


