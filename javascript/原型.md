！！如果回顾的时候着急，直接到最后看图！！
[传送门](#总结图)
## 一、实例
```js
function Car(color) {
    this.color = color;
}
var bmw = new Car('black');
console.log(bmw.color); // black
```
### 实例化发生了什么？
```js
var o = new Object(); //创建一个基本对象
o.__proto__ = Car.prototype;//创建内置属性__proto__并指向构造函数的prototype;
Car.call(o, 'black');//调用构造函数来构造自身，此时this指向自身，从而获得成员变量color
return o; //返回对象
```

**如果构造函数有返回值呢？**
```js
function Car(color) {
    this.color = color;
    //return any;
}
```
1. 没有返回值 ：默认情况，返回该实例
2. 简单数据类型 ：返回该实例
3. 对象类型 ：返回这个对象类型(any)，而不是实例(o)

## prototype
1. prototype是函数才有的属性，且每个函数都有一个prototype属性。
2. prototype指向(是)一个对象，这个对象是调用构造函数(Car)所创建的**实例**(bmw)**的原型**。
3. Car的prototype指向Car.prototype(Car实例的原型)。(不是废话)

## 原型
 每一个JavaScript**对象**(除了null)**在创建时**就会与之关联**的**另一个对象，这个**关联对象**就是原型，每一个对象都会从原型"继承"属性。

##  \_\_proto\_\_
1. 每一个JavaScript对象(除了null)都具有的一个内置属性，指向该对象的原型。
2. __proto__是一个基本对象，它来自于Object.prototype。(这点很重要) 

```js
console.log(bmw.__proto__ === Car.prototype); //true
```

## constructor
每个原型都有一个constructor属性指向关联的构造函数。
```js
console.log(Car === Car.prototype.constructor); //true
```

## 实例属性的查找

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

## 原型链
图片引用自 https://github.com/mqyqingfeng/Blog/issues/2

图中蓝色线条即原型链
![image](https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype5.png)


## 小结
函数在创建的时候，Object会同时创建一个对象(个人理解)，以下称为**o**，函数的prototype属性会指向**o**。

**o**会作为函数实例的原型，无论函数有多少实例，这些实例的原型都是**o**。

实例化的时候，Object又为实例创建了一个对象属性__proto__,通过__proto__可以访问到该实例的原型**o**。

因为函数的prototype指向原型**o**，而函数的实例又可以通过__proto__访问原型**o**，所以，可以不负责任的认为，函数的prototype就是它实例的原型。

既然原型**o**本身就是个对象，那对象又可以通过__proto__访问到**o**的原型，这样的原型找原型的方式，形成了一条**原型链**。

## 总结图
如图所示，有一点很特别 Function.\_\_proto\_\_ === Function.prototype。首先这是规范定制的，其次Function是函数，当然应该由函数原型来构造。

![image](http://www.mollypages.org/tutorials/jsobj.jpg)

备用地址
![image](../image/prototype.png)


