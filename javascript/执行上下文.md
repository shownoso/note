# 执行上下文
执行上下文是 JavaScript 执行一段代码时的运行环境。其产生可以参考[V8-Js Execution](../browser/v8-js.md)。

## 组成
以 ES5 为参考进行表述（[更多参考](#执行上下文组成的不同参考)）：
- lexical environment：词法环境。
- variable environment：变量环境。
- this value：this 值。

## 执行上下文栈
又称调用栈，js 引擎用来管理执行上下文的栈结构。
- 函数执行时，创建该函数的执行上下文并压入执行上下文栈。
- 执行结束后，将该函数的执行上下文从栈中弹出。
- 栈溢出: 分配的调用栈空间超出额定数值。

## 变量提升
在编译阶段，变量和函数的声明被放入内存中；编译完成后再进入执行阶段，所以声明在执行之前。
- 和变量相比，函数会被优先提升。
- *变量环境* 保存了变量提升的内容。

### 变量的创建、初始化和赋值
变量需要初始化才可以被使用
- var：创建且初始化为 undefined。
- 函数：创建且初始化并赋值。
- let、const：创建但未初始化，存在暂时性死区（TDZ），从创建提升的角度来看，存在变量提升。

## 作用域
1. Global Scope：全局作用域
2. Function Scope：函数作用域
3. Block Scope：块级作用域
    - with：别用，有变量指向歧义，可以用解构代替
    - try catch
    - let、const（ES6）

### 作用域（块）与词法环境
在词法环境内部，维护了一个小型栈结构，用于块级作用域中变量（let、const）的管理。  
其中，栈底是外层的变量（let、const），与执行上下文栈的行为类似，当进入一个块后，就会把该块内部的变量压入栈顶；当该块作用域执行完毕后，其作用域的信息就会从栈顶弹出。

```js
// ES6 既实现变量提升，又支持块级作用域
function foo(){
    // foo 函数级作用域 
    var a = 1; // 提升至变量环境
    let b = 2; // 被压到词法环境内部栈栈底，用于下方块级作用域的访问
    { // 该块内变量将被压入词法环境
        let b = 3; // 属于当前块
        var c = 4; // 函数级提升到变量环境
        let d = 5; // 属于当前块
        // 先从当前词法环境查找，若无，则从外部变量环境查找
        console.log(a); // 1 当前词法环境无，那么从块外部的变量环境查找
        console.log(b); // 3 先从当前词法环境查找
    }
    console.log(b); // 2 无法访问块，直接变量环境查找
    console.log(c); // 4 变量环境
    console.log(d); // Uncaught ReferenceError: d is not defined 无法访问块，且变量环境及全局中也未定义
}   
foo();
```

![block-scope-lexical](../image/block-scope-lexical.png)

## 旧时代的 AO/VO

### 变量对象(Variable Object)
1. 每一个执行上下文都会分配一个变量对象。
2. 变量对象由 变量声明 和 函数声明 构成。
3. 特别的，在函数上下文条件下，参数列表 arguments 也会被加入到变量对象中（通过创建活动对象）。

### 活动对象(Activation Object)
当函数执行，arguments 将初始化一个 活动对象 并分配给当前执行上下文。随后，它被当做变量对象用于变量初始化： VO = [AO, ...VariableDeclaration, ...FunctionDeclaration]。
- 存在变量提升
- 不加 var 的且上下文没有该变量赋值操作会（隐式地）声明成全局（window）的变量，需要注意严格模式下的执行。
   
## 作用域链
1. 包含一组词法作用域父级，用于外部变量查找 
2. 由多个执行上下文的**变量对象构成的链表**
3. 当前执行上下文的作用域链由当前环境的变量对象及父级(词法)上下文的作用域链构成：current-scope = [VO, parentScopeChain]。

### [this](./this.md)
创建当前 EC 的 this: ObjectThis || global || window || undefined



### 执行
完成了执行上下文的一系列"初始化工作"，下面开始代码执行。
1. js的语法顺序是中缀的，即赋值操作在中间；
2. RHS与LHS
    - LHS： 操作的目标
        - Identifier 或 MemberExpression
        - 若失败 ReferenceError 或 TypeError
    - RHS： 操作的源头
3. 查找
    - 先在当前的VO/AO查找，若无则再按照作用域链依次向上查找，最终找不到则失败并报错。

### [闭包](./闭包.md)。


### 小结
1. this: 动态绑定
2. 变量提升: AO
3. 作用域链: [[Scopes]]: [AO,ParentContext.VO,GlobalContext.VO]
4. 闭包： Closure(outside) ==> [[Scopes]]

### 流程
```js
var a = 1;

function bar() {
    console.log(a)
}

function foo() {
    var a = 2;
    function baz() {
        console.log(a)
    }

    bar();
    baz();
}

foo();
```
1. 执行全局代码，创建全局上下文并压入执行上下文栈
```
ECStack = [
    globalContext
];
```
2. 全局上下文初始化，函数bar和函数foo被创建，并保存当前上下文(全局)作用域链到内部属性[[scope]]。
```
globalContext = {
    VO: [global],
    Scope: [globalContext.VO],
    this: globalContext.VO
}

bar.[[scope]] = [
    globalContext.VO
];

foo.[[scope]] = [
    globalContext.VO
];
```
3. 执行foo，创建foo的函数执行上下文并压入执行上下文栈
```
ECStack = [
    fooContext,
    globalContext
];
```
4. foo函数执行上下文初始化
    - 复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链
    - 使用参数列表arguments创建活动对象AO
    - AO被当做变量对象VO用于变量初始化并将变量对象压入作用域链顶端
        * 函数baz被创建，同时将当前执行上下文的作用域链压入内部属性[[scope]]
```
fooContext = {
    AO: {
        arguments: {
            length: 0
        },
        a: undefined,
        baz: reference to function baz(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}

baz.[[scope]] = [
    fooContext.Scope
];
```
**foo内代码顺序执行，foo.VO改变，foo上下文中的a被赋值为2**    

5. 执行到bar，创建bar的函数执行上下文并压入执行上下文栈
```
ECStack = [
    barContext,
    fooContext,
    globalContext
];
```
6. bar函数执行上下文初始化,复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链，因此执行完成后结果 在全局中找到a为1，弹出bar的上下文
```
//上下文初始化  注意：bar.[[scope]] = [globalContext.VO];
barContext = {
    AO: {
        arguments: {
            length: 0
        },
    },
    Scope: [AO, globalContext.VO], 
    this: undefined
}

//执行 在globalContext.VO中找到a为1
//执行完毕 弹出上下文
ECStack = [
    fooContext,
    globalContext
];
```
7. 执行baz，创建baz的函数执行上下文并压入执行上下文栈
```
ECStack = [
    bazContext,
    fooContext,
    globalContext
];
```
8. bar函数执行上下文初始化,复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链，因此执行完成后结果 在foo.VO中找到a为2，弹出baz的上下文
```
//上下文初始化  注意：baz.[[scope]] = [fooContext.Scope];
// [fooContext.Scope] = [foo.VO, globalContext.VO];
bazContext = {
    AO: {
        arguments: {
            length: 0
        },
    },
    Scope: [AO, foo.VO, globalContext.VO], 
    this: undefined
}

//执行 在foo.VO中找到a为2
//执行完毕 弹出上下文
ECStack = [
    fooContext,
    globalContext
];
```

9. foo执行结束 弹出foo的执行上下文
```
ECStack = [
    globalContext
];
```


## 附录

### 执行上下文组成的不同参考
```
ES3：
scope：作用域，引申为作用域链。
variable object：变量对象，用于存储变量的对象。
this value：this 值。

ES5：
lexical environment：词法环境。
variable environment：变量环境。
this value：this 值。

ES 2018：
lexical environment：词法环境，当获取变量或者 this 值时使用。
variable environment：变量环境，当声明变量时使用。
code evaluation state：用于恢复代码执行位置。
Function：执行的任务是函数时使用，表示正在被执行的函数。
ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
Realm：使用的基础库和内置对象实例。
Generator：仅生成器上下文有这个属性，表示当前生成器。
```

