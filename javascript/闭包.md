## [闭包](./basement/closure/closure1.js)
1. 闭包是函数和声明该函数的词法环境的组合。
2. 通常闭包是指那些能够访问自由变量的函数。
3. 产生：当函数（假设函数名为outside）执行上下文被创建后，对内部所有函数进行扫描，发现内部有函数（一个或多个，假设函数名（或将匿名函数指代）为Inner）对当前作用域内变量有存在引用的情况，那么将这些所有被引用到的变量组合成一个叫做闭包的引用，?压入inner等使用变量的函数的[[Scopes]]或者说标记到该函数上?存疑。
 - 火狐： 如果函数直接在Outside内执行，那么将不对未引用变量进行优化。函数不在Outside内执行时，火狐会进行引用变量优化。
 - 谷歌： 表现为创建一个被Inner使用的Closure (Outside)

 ```js
  [[Scopes]]: [
    Closure {}, // 闭包
    // ......  根据作用域链的概念，可能存在多级闭包
    Global {},
  ]
 ```

### 自由变量
被函数使用了的变量，但既不是参数也不是局部变量。

### 实践中的闭包
满足条件：
1. 即使函数的上下文已经销毁，它仍然存在
2. 引用了自由变量

### 影响及注意点
1. 时间
    - 闭包中的变量由于已被解析并驻于内存（直到函数销毁被GC回收），所以相同逻辑下能够提高执行效率
    - 需要多一层或者几层变量查找，增加了变量查找范围和时间
    - 一般情况下，变量查找耗时可几乎忽略不计
2. 空间
    - 占用内存空间
    - 空间换时间

3. 回收： 干掉使用了闭包的那个函数 fn = null

