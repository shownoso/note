### 可执的行代码类型
1. 全局代码
2. 函数
3. eval：（别用，有性能和安全问题，另外还有new Function();） 

### 执行上下文栈(Execution Context Stack)
1. 管理一系列执行上下文的数据结构, 最底部为全局EC
2. 执行函数时，将创建的上下文会被压入其中；函数执行完毕后，将该函数的执行上下文弹出。


### 执行上下文(Execution Context)
**执行**一段代码时，会创建对应的执行上下文，包括：
1. 变量对象(Variable object，VO)。GO：全局变量对象
2. 作用域链(Scope chain)
3. this

```js
{
  VO/AO：{
    arguments?: ArrayLike<ANY>, //执行时由arguments初始化AO
    [declarations]: ANY, // 变量声明及函数声明
  },
  [[Scopes]]: [
    Scope {}, // 父级作用域
    // ......多级父级作用域
    Global {}, // 全局作用域
  ],
  `this`: {} || undefined,
}
```


### 变量对象(Variable Object)
1. 每一个执行上下文都会分配一个变量对象
2. 变量对象由**变量声明**（VariableDeclaration）和**函数声明**（FunctionDeclaration）构成
3. 特别的，在函数上下文条件下(函数执行)，参数列表(arguments)也会被加入到变量对象中 => 活动对象。

### 活动对象(Activation Object)
当函数被**激活（执行）**，arguments将初始化一个**活动对象**并且分配给执行上下文。随后，它被当做变量对象用于变量初始化： VO = [AO, ...VariableDeclaration, ...FunctionDeclaration]。
+ 同名声明将覆盖， 函数优先
+ let、const仅提升声明，未初始化
+ 不加 var 的且上下文没有该变量赋值操作会（隐式地）声明成全局变量（global/window）
+ 需要注意函数执行时是否在严格模式
   

### 作用域
JavaScript采用词法作用域(lexical scoping)，即静态作用域。
1. 静态作用域：**函数定义**时决定
2. 动态作用域：**函数调用**时决定

#### 作用域级别
1. Global Scope：全局作用域
2. Function Scope：函数作用域
3. Block Scope：块级作用域
    - with（别用，有变量指向歧义，可以用解构代替）
    - try catch
    - let、const

#### 作用域链 （存疑）
1. 包含一组词法作用域父级，用于外部变量查找 
2. 由多个执行上下文的**变量对象构成的链表**
3. 当前执行上下文的作用域链由当前环境的变量对象及父级(词法)上下文的作用域链构成：current-scope = [VO, parentScopeChain]。

### [this](./this.md)
创建当前 EC 的 this: ObjectThis || global || window || undefined


### 执行
完成了执行上下文的一系列"初始化工作"，下面开始代码执行。
1. js的语法顺序是中缀的，即赋值操作在中间；
2. RHS与LHS
    - LHS： 操作的目标
        - Identifier 或 MemberExpression
        - 若失败 ReferenceError 或 TypeError
    - RHS： 操作的源头
3. 查找
    - 先在当前的VO/AO查找，若无则再按照作用域链依次向上查找，最终找不到则失败并报错。

### [闭包](./闭包.md)。



### 流程解释
```js
var a = 1;

function bar() {
    console.log(a)
}

function foo() {
    var a = 2;
    function baz() {
        console.log(a)
    }

    bar();
    baz();
}

foo();
```
1. 执行全局代码，创建全局上下文并压入执行上下文栈
```
ECStack = [
    globalContext
];
```
2. 全局上下文初始化，函数bar和函数foo被创建，并保存当前上下文(全局)作用域链到内部属性[[scope]]。
```
globalContext = {
    VO: [global],
    Scope: [globalContext.VO],
    this: globalContext.VO
}

bar.[[scope]] = [
    globalContext.VO
];

foo.[[scope]] = [
    globalContext.VO
];
```
3. 执行foo，创建foo的函数执行上下文并压入执行上下文栈
```
ECStack = [
    fooContext,
    globalContext
];
```
4. foo函数执行上下文初始化
    - 复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链
    - 使用参数列表arguments创建活动对象AO
    - AO被当做变量对象VO用于变量初始化并将变量对象压入作用域链顶端
        * 函数baz被创建，同时将当前执行上下文的作用域链压入内部属性[[scope]]
```
fooContext = {
    AO: {
        arguments: {
            length: 0
        },
        a: undefined,
        baz: reference to function baz(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}

baz.[[scope]] = [
    fooContext.Scope
];
```
**foo内代码顺序执行，foo.VO改变，foo上下文中的a被赋值为2**    

5. 执行到bar，创建bar的函数执行上下文并压入执行上下文栈
```
ECStack = [
    barContext,
    fooContext,
    globalContext
];
```
6. bar函数执行上下文初始化,复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链，因此执行完成后结果 在全局中找到a为1，弹出bar的上下文
```
//上下文初始化  注意：bar.[[scope]] = [globalContext.VO];
barContext = {
    AO: {
        arguments: {
            length: 0
        },
    },
    Scope: [AO, globalContext.VO], 
    this: undefined
}

//执行 在globalContext.VO中找到a为1
//执行完毕 弹出上下文
ECStack = [
    fooContext,
    globalContext
];
```
7. 执行baz，创建baz的函数执行上下文并压入执行上下文栈
```
ECStack = [
    bazContext,
    fooContext,
    globalContext
];
```
8. bar函数执行上下文初始化,复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链，因此执行完成后结果 在foo.VO中找到a为2，弹出baz的上下文
```
//上下文初始化  注意：baz.[[scope]] = [fooContext.Scope];
// [fooContext.Scope] = [foo.VO, globalContext.VO];
bazContext = {
    AO: {
        arguments: {
            length: 0
        },
    },
    Scope: [AO, foo.VO, globalContext.VO], 
    this: undefined
}

//执行 在foo.VO中找到a为2
//执行完毕 弹出上下文
ECStack = [
    fooContext,
    globalContext
];
```

9. foo执行结束 弹出foo的执行上下文
```
ECStack = [
    globalContext
];
```



