### 可执行代码(Executable code)
1. 全局代码
2. 函数
3. eval

### 执行上下文(Execution context)
**执行**一段可执行代码时，会创建对应的执行上下文：
1. 变量对象(Variable object，VO)
2. 作用域链(Scope chain)
3. this

### 执行上下文栈(Execution context stack)
1. js解释器在运行阶段会维护一个栈(全局上下文会最先被压入栈底)
2. 执行函数时创建的上下文会被压入执行上下文栈，当函数执行完毕后，会将该函数的执行上下文从栈中弹出。
    + 进入执行上下文
    + 代码执行，根据代码，修改变量对象的值


### 变量对象(Variable object)
1. 每一个执行上下文都会分配一个变量对象
2. 变量对象由**变量**和**函数声明**构成(函数声明而非函数表达式)
3. 特别的，在函数上下文条件下，参数列表(arguments)也会被加入到变量对象中
    + 当函数被激活，arguments将初始化一个**活动对象(Activation object)**并且分配给执行上下文。随后，它被当做变量对象用于变量初始化： VO = [AO, ...Variable, ...Function-declaration]。


### 作用域
1. 源代码中定义变量的区域
2. 规定了如何查找变量，即确定当前执行代码对变量的访问权限
JavaScript采用词法作用域(lexical scoping)，也就是静态作用域。
#### 静态与动态
1. 静态作用域：**函数定义**时决定
2. 动态作用域：**函数调用**时决定

### 作用域链
1. 变量查找的范围
2. 由多个执行上下文的**变量对象构成的链表**
3. 当前执行上下文的作用域链由当前环境的变量对象及父级(词法)上下文的作用域链构成：current-scope = [VO, parentScopeChain]。


### 流程解释
```
var a = 1;

function bar() {
    console.log(a)
}

function foo() {
    var a = 2;
    function baz() {
        console.log(a)
    }

    bar();
    baz();
}

foo();
```
1. 执行全局代码，创建全局上下文并压入执行上下文栈
2. 全局上下文初始化，函数bar和函数foo被创建，并保存当前上下文(全局)作用域链到内部属性[[scope]]。
3. 执行foo，创建foo的函数执行上下文并压入执行上下文栈
4. foo函数执行上下文初始化
    - 复制函数内部属性[[scope]]并以此创建该执行上下文的作用域链
    - 使用参数列表arguments创建活动对象AO
    - AO被当做变量对象VO用于变量初始化并将变量对象压入作用域链顶端
        * 函数baz被创建，同时将当前执行上下文的作用域链保存到内部属性[[scope]]
5. 执行bar，创建bar的函数执行上下文并压入执行上下文栈
6. bar函数执行上下文初始化,此时bar的作用域链为全局上下文的作用域链，因此执行完成后结果 在全局中找到a为1，弹出bar的上下文
7. 执行baz，创建baz的函数执行上下文并压入执行上下文栈
8. baz函数执行上下文初始化,此时baz的作用域链为[bazAO,fooVO,globalVO], 因此执行完成后结果 在fooVO中找到a为2，弹出baz的上下文
9. foo执行结束 弹出foo的执行上下文



